<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-01-03">
<meta name="description" content="Large Language Model Optimization techniques - an overview of attention mechanisms">

<title>The Power of Focus: Understanding Attention Mechanisms in LLM – Marcel Castro</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-3cc21f40eb8113f7106139c3b957be44.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-RK1QNXR9TB"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-RK1QNXR9TB', { 'anonymize_ip': true});
</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Marcel Castro</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://marcelcastrobr.github.io/my_ml_notes/"> 
<span class="menu-text">Notes</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Notebooks</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://marcelcastrobr.github.io/my_ml_links/"> 
<span class="menu-text">Links</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/marcelcastrobr/marcelcastrobr.github.io/blob/main/cv/cv-marcelcastro.pdf"> <i class="bi bi-filetype-pdf" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://marcelcastrobr.github.io/my_ml_links/"> <i class="bi bi-diagram-3-fill" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://huggingface.co/marcelcastrobr"> <i class="bi bi-emoji-smile" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/marcelcastrobr"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/marcelcastrobr/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">The Power of Focus: Understanding Attention Mechanisms in LLM</h1>
                  <div>
        <div class="description">
          Large Language Model Optimization techniques - an overview of attention mechanisms
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">transformers, LLM</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 3, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#the-power-of-focus-understanding-attention-mechanisms-in-llm" id="toc-the-power-of-focus-understanding-attention-mechanisms-in-llm" class="nav-link active" data-scroll-target="#the-power-of-focus-understanding-attention-mechanisms-in-llm">The Power of Focus: Understanding Attention Mechanisms in LLM</a>
  <ul class="collapse">
  <li><a href="#background" id="toc-background" class="nav-link" data-scroll-target="#background">Background</a></li>
  <li><a href="#attention-mechanism---a-short-introduction" id="toc-attention-mechanism---a-short-introduction" class="nav-link" data-scroll-target="#attention-mechanism---a-short-introduction">Attention Mechanism - A Short Introduction</a></li>
  <li><a href="#flashattention" id="toc-flashattention" class="nav-link" data-scroll-target="#flashattention">FlashAttention</a>
  <ul class="collapse">
  <li><a href="#flashattention-solution" id="toc-flashattention-solution" class="nav-link" data-scroll-target="#flashattention-solution">FlashAttention Solution</a></li>
  <li><a href="#flashattention-at-pytorch" id="toc-flashattention-at-pytorch" class="nav-link" data-scroll-target="#flashattention-at-pytorch">FlashAttention at PyTorch</a></li>
  </ul></li>
  <li><a href="#pagedattention" id="toc-pagedattention" class="nav-link" data-scroll-target="#pagedattention">PagedAttention</a></li>
  <li><a href="#multi-head-latent-attention" id="toc-multi-head-latent-attention" class="nav-link" data-scroll-target="#multi-head-latent-attention">Multi-Head Latent Attention</a></li>
  </ul></li>
  <li><a href="#more-references" id="toc-more-references" class="nav-link" data-scroll-target="#more-references">More References:</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="the-power-of-focus-understanding-attention-mechanisms-in-llm" class="level1">
<h1>The Power of Focus: Understanding Attention Mechanisms in LLM</h1>
<p>[TOC]</p>
<section id="background" class="level2">
<h2 class="anchored" data-anchor-id="background">Background</h2>
<p>Nowadays, there are several fronts on improving Large Language Models at both inference and training. Techniques such as quantization, distillation and optimizations at the attention mechanism are continuously been improved to either reduce model size or memory footprint.</p>
<p>For example, in quantization the use of <strong><a href="https://arxiv.org/abs/2208.07339">Int8</a></strong> type at inference can reduce memory footprint of large models by a factor of 2x.</p>
<p>The sequential generation process of autoregressive transformer which generates words (tokens) one at a time based on the input prompt and previous sequence, makes the GPU workload <strong>memory-bound</strong>, underutilizing the computation power of GPUs and limiting the serving throughput.</p>
<p>In order to make sure workloads are predominantly <strong>compute-bound</strong> at GPUs (and not memory-bound) several solutions have been proposed to optimize the attention mechanism commonly used by autoregressive transformer, which includes <strong>FlashAttention</strong>, <strong>PagedAttention</strong> and <strong>Multi-Head Latent Attention</strong> discussed below.</p>
<p>But before diving into those mechanism, let have a quick overview of attention mechanism. In this article we are focusing on autoregressive attention mechanism (i.e.&nbsp;attention for decoder-only models).</p>
</section>
<section id="attention-mechanism---a-short-introduction" class="level2">
<h2 class="anchored" data-anchor-id="attention-mechanism---a-short-introduction">Attention Mechanism - A Short Introduction</h2>
<p><strong>A Brief history…</strong></p>
<p>Prior to Transformers, RNN (Recurrent Neural Network) was the state of the art on NLP (Natural Language Processing) tasks such as translation. But a short-coming of RNNs is that it losses context in complex sentences where dependencies span long distance. This due to the fact that the encoder-decoder RNNs was unable to direct access earlier hidden states during decoding phase and therefore RNN was forced to remember the entire encoded input in a single hidden state before passing it to the decoder. [<a href="https://github.com/rasbt/LLMs-from-scratch/">S Raschka</a>].</p>
<p>Bahdanau attention mechanism for RNN was proposed in 2014 as a way for RNN to selective access different parts of the input sequence at each decoding step. The Transformer architecture included the self-attention mechanism inspired by Bahdanau attention mechanism. The basic idea of the attention mechanism is to identify high correlation patterns among words in a given sentence, assuming it has learned word correlation patterns from the training data.</p>
<p><strong>How Self-Attention works …</strong></p>
<p>The diagram below from <a href="https://en.wikipedia.org/wiki/Attention_%28machine_learning%29">Wikipedia</a> shows the attention forward pass calculation correlations of the word “that” with the other words in the sentence ” See that girl run.” Basically, given the right weights from training, the network can identify “girl” as the next token (i.e.&nbsp;highest correlated word in the sentence).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./assets/Attention-qkv.png" class="img-fluid figure-img"></p>
<figcaption>Attention-qkv</figcaption>
</figure>
</div>
<p>Picture by <a href="https://en.wikipedia.org/wiki/Attention_%28machine_learning%29">Wikipedia</a>.</p>
<p><strong>From Self-Attention to Multi-Head Attention …</strong></p>
<p>Multi-head attention contains multiple self-attention blocks in order to encapsulate multiple complex relationship between different items in a sequence. In practice, the implementation of multi-head attention represents multiple instances of the self-attention, each with its own weights (i.e.&nbsp;different learned linear projections).</p>
<p>Other efficient adaptation of the multi-head attention is for example the <a href="https://arxiv.org/pdf/2305.13245v3">Grouped-Query Attention</a> and <a href="https://arxiv.org/pdf/1911.02150">Multi-Query Attention</a>. Grouped-query attention is used by models like Llama 3.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./assets/image-20250103143203890.png" class="img-fluid figure-img"></p>
<figcaption>image-20250103143203890</figcaption>
</figure>
</div>
<p>Picture by <a href="https://arxiv.org/pdf/1911.02150">Multi-Query Attention</a></p>
<p><strong>Reference:</strong></p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Attention_%28machine_learning%29">Attention (machine learning) by Wikipedia</a></li>
<li><a href="https://medium.com/perceptronai/a-study-on-attention-mechanism-7d199cf783b6">A Study of Attention Mechanism by Nilesh Barla</a></li>
<li><a href="https://github.com/rasbt/LLMs-from-scratch/">Build A Large Language Model by Sebastian Raschka</a></li>
<li><a href="https://github.com/HandsOnLLM/Hands-On-Large-Language-Models">Hands-On Large Language Models - Language Understanding and Generation by J. Alammar</a></li>
<li><a href="https://arxiv.org/abs/1911.02150">Fast Transformer Decoding: One Write-Head is All You Need by N. Shazeer</a></li>
<li><a href="https://arxiv.org/pdf/2305.13245v3">GQA: Training Generalized Multi-Query Transformer Models from Multi-Head Checkpoints by J. Ainslie et. al.</a></li>
</ul>
</section>
<section id="flashattention" class="level2">
<h2 class="anchored" data-anchor-id="flashattention">FlashAttention</h2>
<p>The attention layer is the main bottleneck in scaling longer sequences, as its runtime and memory increase quadratically in the sequence length [ref. <a href="https://arxiv.org/abs/2307.08691">FlashAttention-2</a>].</p>
<p>To reduce computational requirement of attention on such long context, techniques such as <strong><em>FlashAttention</em></strong> has been proposed to reorder the attention computation and leverages classical techniques such as tilling and recomputation, to speed up and reduce memory usage from quadratic to linear in sequence length (<strong>2-4x faster</strong> than a standard attention implementation).</p>
<p>To check the list of flash attention adopters, check https://github.com/Dao-AILab/flash-attention/blob/main/usage.md</p>
<p>Before diving into Flash Attention we need to introduce the GPU hardware characteristics</p>
<section id="gpu-hardware-characteristics" class="level5">
<h5 class="anchored" data-anchor-id="gpu-hardware-characteristics">GPU Hardware Characteristics</h5>
<p>Main components of a modern GPU are:</p>
<ul>
<li>On-chip SRAM (a.k.a. as shared memory e.g.&nbsp;A100 19TB/s - 192KB per 108 streaming)</li>
<li>HBM (High Bandwidth Memory) (e.g.&nbsp;A100 - 40-80GB and 1.5-2.0TB/s )</li>
<li>SM (streaming multiprocessor) (e.g.&nbsp;A100 - 108 stream multiprocessors )
<ul>
<li>1 SM - 1 Thread block -&gt; Warp (1 warp - 32 threads)</li>
</ul></li>
</ul>
<p><img src="./images/image-20240506084744829.png" alt="image-20240506084744829" style="zoom:50%;"></p>
<p>Picture By Deep Learning Hero. How does matrix multiplication work inside GPUs - https://www.youtube.com/watch?v=wIPdrbZIeKE</p>
<p>In GPUs, operations are executed in threads (a.k.a. kernel). Threads are organized into thread blocks, which are scheduled to run on streaming multiprocessors (SMs)</p>
<p>Within each thread blocks, threads are grouped into warps ( 1 warp equal 3 threads). Threads within a warp can communicate by fast shuffe instructions or cooperate to perform matrix multiply.</p>
<p>Warps within a thread block can communicate by reading from and writing to shared memory. Each kernel loads inputs from HBM to registers and SRAM, computes, then writes outputs to HBM.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/image-20240506135327900.png" class="img-fluid figure-img"></p>
<figcaption>image-20240506135327900</figcaption>
</figure>
</div>
<p>Picture By Deep Learning Hero. How does matrix multiplication work inside GPUs - https://www.youtube.com/watch?v=wIPdrbZIeKE</p>
<p><img src="./images/image-20240506094321755.png" alt="image-20240506094321755" style="zoom:50%;"></p>
<p>Picture by Dissecting the Ampere GPU Architecture through Microbenchmarking - https://www.nvidia.com/en-us/on-demand/session/gtcspring21-s33322/</p>
<p>Table below shows the comparison between certain GPU types across its main characteristics.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>GPU Type</th>
<th>Architecture</th>
<th>SM</th>
<th>HBM</th>
<th>SRAM</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://www.nvidia.com/en-us/data-center/a100/">A100</a></td>
<td>NVIDIA Ampere</td>
<td>108</td>
<td>40 GB (1.5TB/s)</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><a href="https://developer.nvidia.com/blog/nvidia-hopper-architecture-in-depth/">H100</a></td>
<td>NVIDIA Hopper</td>
<td>144</td>
<td>80GB (2.0TB/s)</td>
<td></td>
<td>Tensor Memory Accelerator, DPX (Dynamic Programming) Instructions, FP8 Tensor Cores, DSMEM (Distributed Shared Memory)</td>
</tr>
<tr class="odd">
<td><a href="https://www.nvidia.com/en-us/data-center/h200/">H200</a></td>
<td>NVIDIA Hopper</td>
<td></td>
<td>141GB (4.8TB/s)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="flashattention-solution" class="level3">
<h3 class="anchored" data-anchor-id="flashattention-solution">FlashAttention Solution</h3>
<p>Lots of data loading turns computation in memory bound and not compute bound.</p>
<p>For each attention head, to reduce memory reads/writes, <strong>FlashAttention</strong> uses <em>classical tiling techniques to load blocks of query, key, and value from GPU HBM (its main memory) to SRAM (its fast cache)</em>, compute attention with respect to that block, and write back the output to HBM. This reduction in memory reads/writes brings significant speedup (2-4x) in most cases. [ref. https://www.adept.ai/blog/flashier-attention]</p>
<p>The figure below is from <a href="https://arxiv.org/pdf/2205.14135">FlashAttention paper</a> showing on the left that FlashAttention uses tiling to prevent materialization of the large 𝑁 × 𝑁 attention matrix (dotted box) on (relatively) slow GPU HBM.</p>
<p>Here in the outer loop (red arrows), FlashAttention loops through blocks of the K and V matrices and loads them to fast on-chip SRAM. In each block, FlashAttention loops over blocks of Q matrix (blue arrows), loading them to SRAM, and writing the output of the attention computation back to HBM.</p>
<p>On the right you see the speedup over the PyTorch implementation of attention on GPT-2. FlashAttention does not read and write the large 𝑁 × 𝑁 attention matrix to HBM, resulting in an 7.6× speedup on the attention computation according to the paper.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/image-20240507155528488.png" class="img-fluid figure-img"></p>
<figcaption>image-20240507155528488</figcaption>
</figure>
</div>
</section>
<section id="flashattention-at-pytorch" class="level3">
<h3 class="anchored" data-anchor-id="flashattention-at-pytorch">FlashAttention at PyTorch</h3>
<p>PyTorch implements flash attention at https://pytorch.org/docs/stable/generated/torch.nn.functional.scaled_dot_product_attention.html.</p>
<p>Below is a code snipped example from <a href="https://github.com/thushv89/tutorials_deeplearninghero/blob/master/llms/flash_attention_torch.ipynb">DeepLearning Hero</a> using pytorch.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.backends.cuda.sdp_kernel(</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>        enable_flash<span class="op">=</span><span class="va">False</span>, enable_math<span class="op">=</span><span class="va">True</span>, enable_mem_efficient<span class="op">=</span><span class="va">True</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>):</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Check <a href="https://marcelcastrobr.github.io/posts/2024-04-07-flashattention.html">FlashAttention - Fast and Memory Efficient Attention Mechanism</a> in https://marcelcastrobr.github.io/ for a notebook implementation.</p>
<p><strong>References:</strong></p>
<ul>
<li>FlashAttention: Fast and Memory-Efficient Exact Attention with IO-Awareness - https://arxiv.org/abs/2205.14135</li>
<li>FlashAttention-2: Faster Attention with Better Parallelism and Work Partitioning https://arxiv.org/abs/2307.08691</li>
<li>Matrix Multiplication: Inner Product, Outer Product &amp; Systolic Array https://www.adityaagrawal.net/blog/architecture/matrix_multiplication</li>
<li>Benchmarking and Dissecting the Nvidia Hopper GPU Architecture https://arxiv.org/pdf/2402.13499v1</li>
<li>NVIDIA Hopper Architecture In-Depth https://developer.nvidia.com/blog/nvidia-hopper-architecture-in-depth/</li>
<li>FlashAttention: Fast Transformer training with long sequences https://www.adept.ai/blog/flashier-attention</li>
<li>AWS Broadcast https://broadcast.amazon.com/videos/670513?ref=personal</li>
<li>Andrej Karpathy implementation - https://twitter.com/karpathy/status/1786461447654125625?s=51</li>
<li>FlashAttention - Fast and Memory Efficient Attention Mechanism by Marcel Castro - https://marcelcastrobr.github.io/posts/2024-04-07-flashattention.html</li>
</ul>
</section>
</section>
<section id="pagedattention" class="level2">
<h2 class="anchored" data-anchor-id="pagedattention">PagedAttention</h2>
<p>Key-value cache (KV cache) memory for each request in the attention mechanism is huge and grows and shrinks dynamically. When managed inefficiently, this memory can be significantly wasted by fragmentation and redundant duplication, limiting the batch size.</p>
<p>PageAttention propose to improve the LLM throughput by batching multiple requests together. Thus to process many requests in a batch needs an efficient memory management.</p>
<p>As discussed in [<a href="https://arxiv.org/pdf/2309.06180">Efficient Memory Management for Large Language Model Serving with PagedAttention</a>] , approximately 65% of memory is allocated to mode weights which are static parameters during serving (considering a 13Billion parameter model on NVIDIA A100 GPU with 40GB RAM). Close to 30% of the memory is used to store the dynamic states of the requests (a.k.a <strong>KV cache</strong>). The remaining memory is used for other data such as activations.</p>
<p>Since model weights are constant and the activations only occupy a small fraction of the GPU memory, the way KV cache if managed is critical in determining the maximum batch size.</p>
<p><img src="./images/image-20240513100159526.png" alt="image-20240513100159526" style="zoom:50%;"></p>
<p>Picture from Paper <a href="https://arxiv.org/pdf/2309.06180">Efficient Memory Management for Large Language Model Serving with PagedAttention</a>. In the Left: Memory layout when serving an LLM with 13B parameters on NVIDIA A100. The parameters (gray) persist in GPU memory throughout serving. The memory for the KV cache (red) is (de)allocated per serving request. A small amount of memory (yellow) is used ephemerally for activation. Right: vLLM smooths out the rapid growth curve of KV cache memory seen in existing systems [31, 60], leading to a notable boost in serving throughput.</p>
<p>PageAttention solution is inspired by the operating system solution to memory fragmentation and sharing: <em>virtual memory with paging</em>. KV cache is divided into blocks, where the blocks are not necessarily stored in contiguous space (i.e.&nbsp;think blocks as pages, tokens as bytes and requests as processes). This allows PagedAttention to achieve:</p>
<ul>
<li>near-zero waste in KV cache memory.</li>
<li>flexible sharing of KV cache within and across requests to further reduce memory usage.</li>
</ul>
<p><strong>References:</strong></p>
<ul>
<li>[Efficient Memory Management for Large Language Model Serving with PagedAttention - https://arxiv.org/pdf/2309.06180]</li>
</ul>
</section>
<section id="multi-head-latent-attention" class="level2">
<h2 class="anchored" data-anchor-id="multi-head-latent-attention">Multi-Head Latent Attention</h2>
<p>As pointed out by Aleksa Gordic <a href="https://www.linkedin.com/posts/aleksagordic_flying-to-usa-got-some-time-to-read-deepseek-activity-7274906448378101760-KEvU?utm_source=share&amp;utm_medium=member_desktop">here</a>, Multi-Head Latent Attention (MLA) is used by <a href="https://github.com/deepseek-ai/DeepSeek-V3/blob/main/DeepSeek_V3.pdf">DeepSeek-v3</a> (671Billion parameter model with 37 Billion activated for each token), currently the world’s most powerful open-source LLM. As Gordic mentioned, the core idea behind MLA is to save a single low-dimension vector that gets projected back into NH (Number of Heads) keys &amp; value vectors (via 2 learnable parameter matrices) before doing the “standard” attention.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./assets/image-20250103135252023.png" class="img-fluid figure-img"></p>
<figcaption>image-20250103135252023</figcaption>
</figure>
</div>
<p>Picture by <a href="https://arxiv.org/pdf/2405.04434">DeepSeek-AI</a></p>
<p>MLA proposes a low-rank joint compression for the attention keys and values in order to reduce KV(Key-Value) cache during inference. MLA also perform a low-rank compression in the attention queries (Q) to reduce the activation memory during training.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./assets/image-20250103111747598.png" class="img-fluid figure-img"></p>
<figcaption>image-20250103111747598</figcaption>
</figure>
</div>
<p>Picture by <a href="https://arxiv.org/pdf/2405.04434">DeepSeek-AI</a></p>
<p><strong>References:</strong></p>
<ul>
<li><a href="https://arxiv.org/pdf/2405.04434">DeepSeek-V2: A Strong, Economical, and Efficient Mixture-of-Experts Language Mode, by DeepSeek-AI</a></li>
</ul>
</section>
</section>
<section id="more-references" class="level1">
<h1>More References:</h1>
<ul>
<li><a href="https://www.youtube.com/watch?v=QQceTDjA4f4">GTC 2022 - How CUDA Programming Works - Stephen Jones, CUDA Architect, NVIDIA.</a></li>
<li><a href="https://huggingface.co/blog/hf-bitsandbytes-integration">A Gentle Introduction to 8-bit Matrix Multiplication for transformers at scale using Hugging Face Transformers, Accelerate and bitsandbytes</a></li>
<li><a href="https://lightning.ai/pages/community/community-discussions/the-ultimate-battle-of-language-models-lit-llama-vs-gpt3.5-vs-bloom-vs/">The Ultimate Battle of Language Models: Lit-LLaMA vs GPT3.5 vs Bloom vs …</a></li>
<li><a href="https://sagemaker.readthedocs.io/en/stable/api/inference/model.html#sagemaker.jumpstart.model.JumpStartModel">SageMaker JumpStartModel API Docs</a></li>
<li>Video: <a href="https://www.youtube.com/watch?v=ahnGLM-RC1Y">A Survey of Techniques for Maximizing LLM Performance, by OpenAI DevDay</a></li>
<li>Yann Lecun, New York University &amp; META Title: Objective-Driven AI: Towards AI systems that can learn, remember, reason, and plan, <a href="https://www.youtube.com/watch?v=MiqLoAZFRSE&amp;t=3983s">video</a>, <a href="https://drive.google.com/file/d/1wzHohvoSgKGZvzOWqZybjm4M4veKR6t3/view?pli=1">ppt</a></li>
<li>IEEE Spectrum - 15 Graphs That Explain the State of AI in 2024 The AI Index tracks the generative AI boom, model costs, and responsible AI use https://spectrum.ieee.org/ai-index-2024</li>
<li><a href="https://goyalpramod.github.io/blogs/Transformers_laid_out/">Transformers Laid Out by Pramod.</a></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/marcelcastrobr\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="marcelcastrobr/marcelcastrobr.github.io" data-repo-id="R_kgDOIwFH3A" data-category="General" data-category-id="DIC_kwDOIwFH3M4Cjnq1" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright 2023, Marcel Castro</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>